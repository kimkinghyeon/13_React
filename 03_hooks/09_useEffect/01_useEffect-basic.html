<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id = "root"></div>

    <!-- 
    hooks 는 리액트 16.8 에서 도입된 기능으로, 함수형 컴포넌트에서 사용 불가능한
    생명주기 메소드의 한계점으로 인해 상태관리 및 렌더링 이후 시점 컨트롤 등, 다양한 무네를 해결하기
    위해 나온 함수 집합을 의미한다.
    컴포넌트가 렌더링 된 이후에 특정 작업을 수행할 필요가 있다면 클래스형 컴포넌트에서는
    componentDidMount 혹은 componentDidUpdate 메소드를 이용하면 된다.
    하지만 함수형 컴포넌트에는 생명주기 API를 사용할 수 없기 때문에,hooks 를 제공하고 있고
    렌더링 이후 작업을 수행할 수 있게 해주는 useEffect 가 있다.
    -->
    <script type = "text/babel">
        const {useEffect} = React;
        function MessagePrinter(props){
            console.log(props.message);
            const {message} = props;
            console.log(message);
            // console.log(React);
            console.log('rendering.....');
            useEffect(() => {
                console.log('rendering end');
                console.log(message);
                
            })
            return(
                <h1>{console.log('rendering Printer')}{message}</h1>
            )
            // 이 위치에서 (마운트 or 업데이트 이후에) 무언가 동작하게 하고 싶지만
            // 동작하지 않는다.
            // 이 시점에서 실행하고 싶은것을 useEffect 를 이용해서 처리할 수 있다.
            // console.log('rendering end');
        }
        const message = 'hello';
        ReactDOM.createRoot(document.getElementById('root')).render(<MessagePrinter message={message}/>);
    </script>
</body>
</html>